OOP
Class — A blueprint created by a programmer for an object. This defines 
a set of attributes that will characterize any object that is instantiated from this class.

Object — An instance of a class. This is the realized version of the class, where 
the class is manifested in the program.
------------------------------------------------

class Shark:
    def swim(self):
        print("The shark is swimming.")

    def be_awesome(self):
        print("The shark is being awesome.")

s = Shark()
s.swim()
s.be_awesome()

------------------------------------------------

class Dog:
    def __init__(self, name):
      self.name = name
      print('dog {name} initiated'.format(name=name))

    def bark(self):
        print("{name} says WOF-WOF!".format(name=self.name))

if __name__ == '__main__':

	d1 = Dog('Buck')
	d1.bark()
	d2 = Dog('Snoopy')
	d3 = Dog('Peppa')

	dogs = [d1, d2, d3]
	[d.bark() for d in dogs]

-------------------------------------------------

class Boy:
	def __init__(self, name, age):
		self.name = name
		self.age = age
	def introduce(self):
		print('Hello, my name is {name}, I am {age} years old'.format(name=self.name, age=self.age))
	def __str__(self):
		return 'Boy [name={name}, age={age}]'.format(name=self.name, age=self.age) 

if __name__ == '__main__':
	misha = Boy('Misha', 11)
	misha.introduce()
	print(misha)
	misha.name = 'Kolya'
	misha.age += 2
	misha.introduce()
	print(misha)

-------------------------------------------------
Инкапсуляция — ограничение доступа к составляющим объект 
компонентам (методам и переменным). Инкапсуляция делает 
некоторые из компонент доступными только внутри класса.
-------------------------------------------------

class Boy:
	def __init__(self, name, age):
		self.__name = name
		self.__age = age
	def introduce(self):
		print('Hello, my name is {name}, I am {age} years old'.format(name=self.__name, age=self.__age))
	def __str__(self):
		return 'Boy [name={name}, age={age}]'.format(name=self.__name, age=self.__age) 
	def get_age(self):
		return self.__age
	def set_age(self, new_age):
		self.__age = new_age

if __name__ == '__main__':
	misha = Boy('Misha', 11)
	misha.introduce()
	print(misha)
	#misha.name = 'Kolya'
	misha.set_age(misha.get_age() + 2)
	misha.introduce()
	print(misha)

-------------------------------------------------
Статические методы и поля
не привязаны к какому-либо одному объекту класса

class Boy:
	adulthood_age = 18

	...

	@staticmethod
	def what_about_boys():
		print('All boys are good!')

if __name__ == '__main__':
	...
	Boy.what_about_boys()
	misha.what_about_boys()
	print(Boy.adulthood_age)
	print(misha.adulthood_age)

-------------------------------------------------
Насследование
класс может наследовать данные и функциональность 
некоторого существующего класса

принцип DRY (Don't Repeat Yourself)

class Tree():
	
	def __init__(self, kind, height):
		self.kind = kind
		self.height = height
	def grow(self, step=0.5):
		self.height += step
	def __str__(self):
		return '{kind}tree  is {height:.1f} metres height'.format(kind=self.kind, height=self.height)

class FruitTree(Tree):
	def __init__(self, kind, height, weight):
		super().__init__(kind, height)
		self.weight = weight
	def __str__(self):
		return super().__str__() + ', weight = {}'.format(self.weight)
	def give_fruits(self):
		print('{kind} tree gives us {weight}kg fruits'.format(kind=self.kind, weight=self.weight))
		

if __name__ == '__main__':
	tree1 = Tree('oak', 5.0)
	tree1.grow()
	print(tree1)
	tree2 = FruitTree('apple', 4.0, 20.0)
	print(tree2)
	tree2.give_fruits()
-------------------------------------------------
Множественное наследование

class MyTime:
	def __init__(self, h=0, m=0, s=0):
		self.h, self.m, self.s = h, m, s
	def __str__(self):
		return '{:0>2d}:{:0>2d}:{:0>2d}'.format(self.h, self.m, self.s)
	def tick(self):
		self.s += 1
		self.m += (self.s // 60)
		self.s %= 60
		self.h += (self.m // 60)
		self.m %= 60
		self.h %= 24

class MyDate:
	def __init__(self, day=1, month=1, year=2019):
		self.day, self.month, self.year = day, month, year
	def __str__(self):
		return '{:0>2d}.{:0>2d}.{:0>4d}'.format(self.day, self.month, self.year)
	def next_day(self):
		if (self.day == 28 and self.month == 2) or\
			(self.day == 30 and self.month in [4, 6, 9, 11]) or\
			(self.day == 31 and self.month in [1, 3, 5, 7, 8, 10, 12]):
			self.day = 1
			self.next_month()
		else:
			self.day += 1
	def next_month(self):
		if self.month == 12:
			self.month = 1
			self.year += 1
		else:
			self.month += 1

class MyDateTime(MyDate, MyTime):

	def __init__(self, day=1, month=1, year=2019, h=0, m=0, s=0):
		MyDate.__init__(self, day, month, year)
		MyTime.__init__(self, h, m, s)

	def __str__(self):
		return MyDate.__str__(self) + ' - ' + MyTime.__str__(self)

	def tick(self):
		MyTime.tick(self)
		if self.s == 0 and self.m == 0 and self.h == 0:
			MyDate.next_day(self)

if __name__ == '__main__':
	t1 = MyTime(23, 59, 55)
	for i in range(10):
		print(t1)
		t1.tick()
	
	d1 = MyDate(28, 12, 2000)
	for i in range(10):
		print(d1)
		d1.next_day()

	m1 = MyDateTime(31, 12, 2018, 23, 59, 55)
	for i in range(10):
		print(m1)
		m1.tick()

-------------------------------------------------
ПОЛИМОРФИЗМ
несколько наследуемых классов, с разной реализацией одного и того же метода

class Student:
	id = 0
	def __init__(self, name):
		self.name = name
		self.id = Student.id
		Student.id += 1
	def __str__(self):
		return 'Student {name}, id={id}'.format(name=self.name, id=self.id)
	def speak(self):
		print('Hi, I am {}, and I am student'.format(self.name))

class Aspirant(Student):
	def __init__(self, name):
		Student.__init__(self, name)
	def __str__(self):
		return 'Aspirant {name}, id={id}'.format(name=self.name, id=self.id)
	def speak(self):
		print('Hi, I am {}, and I am aspirant'.format(self.name))
	def say_hi(self):
		print('Hi!')


if __name__ == '__main__':
	studiki = []
	names = ['Vasya', 'Petya', 'Dasha', 'Masha']
	for i in range(len(names)):
		if i % 2 == 0: 
			studiki.append(Student(names[i]))
		else: 
			studiki.append(Aspirant(names[i]))
	
	for s in studiki:
		print(s)
	for s in studiki:
		s.speak()
		if s.__class__.__name__ == 'Aspirant':
			s.say_hi()
		if isinstance(s, Aspirant):
			s.say_hi()
-------------------------------------------------

MAGIC METHODS

class Fraction:
    def __init__(self, numerator: int, denominator: int):
        self.numerator, self.denominator = numerator, denominator
        self.reduce()

    def reduce(self):
        for i in range(min(self.denominator, self.numerator), 0, -1):
            if self.numerator % i == 0 and self.denominator % i == 0:
                self.numerator //= i
                self.denominator //= i
                break

    def __str__(self):
        if self.numerator == 0:
            return '0'
        else:
            integer_part = self.numerator // self.denominator
            if integer_part == 0:
                return f'{self.numerator}/{self.denominator}'
            else:
                fraction_part = self.numerator - integer_part * self.denominator
                if fraction_part == 0:
                    return f'{integer_part}'
                else:
                    return f'{integer_part} {fraction_part}/{self.denominator}'

    def __add__(self, other):
        return Fraction(self.numerator * other.denominator + self.denominator * other.numerator,
                        self.denominator * other.denominator)
    def __sub__(self, other):
        return Fraction(self.numerator * other.denominator - self.denominator * other.numerator,
                        self.denominator * other.denominator)

    def __float__(self):
        return self.numerator / self.denominator

    def __lt__(self, other):
        return float(self) < float(other)

if __name__ == '__main__':
    f1 = Fraction(25,10)
    print(f1)
    d = {'numerator': 75, 'denominator': 30}
    f2 = Fraction(**d)
    print(f2)
    f3 = f1 - f2
    print(f3)
    f = [Fraction(i, 12) for i in range(1, 12)]
    print(', '.join([str(fr) for fr in f]))
    import random
    random.shuffle(f)
    print(', '.join([str(fr) for fr in f]))
    f.sort(key=lambda x: float(x))
    print(', '.join([str(fr) for fr in f]))
    random.shuffle(f)
    print(', '.join([str(fr) for fr in f]))
    f.sort()
    print(', '.join([str(fr) for fr in f]))

---------------------------------------------------------

from collections import namedtuple


Car = namedtuple('Car', 'color brand')

class Garage:
    def __init__(self):
        self.cars = [
            Car('brown', 'BMW'),
            Car('red', 'Audi'),
            Car('black', 'Hummer'),
        ]
    def __len__(self):
        return len(self.cars)
    def __getitem__(self, pos):
        return self.cars[pos]

g = Garage()
print(len(g))

print(g[0])

for c in g:
    print(c.brand)

----------------------------------------------------------
SORTING

class Kitty:
    def __init__(self, name, age):
        self.name, self.age = name, age
    def __str__(self):
        return f'Kitty {self.name}, age: {self.age}'
    def __lt__(self, other):
        if self.name == other.name:
            return self.age < other.age
        else:
            return self.name < other.name

if __name__ == '__main__':
    names = ['Mimy', 'Angus', 'Mimy', 'Barsik', 'Angus']
    ages = [5, 3, 4, 2, 2]
    cats = [Kitty(name, age) for name, age in zip(names, ages)]
    for cat in sorted(cats, key=lambda x: (x.name, x.age)):
        print(cat)
    for cat in sorted(cats):
        print(cat)
----------------------------------------------------------
Переменное число параметров в конструкторе

class Resistance:
    def __init__(self, r):
        self.resistance = r

    def __str__(self):
        return str(self.resistance)


class SeriesCircuit(Resistance):
	def __init__(self, *res):
		self.resistance = sum([r.resistance for r in res])

class ParallelCircuit(Resistance):
    def __init__(self, *res):
        self.resistance = 1.0 / sum([1.0 / r.resistance for r in res])


if __name__ == '__main__':
    R1 = Resistance(10)
    R2 = Resistance(8)
    R_  = SeriesCircuit(R1, R2)
    R3 = Resistance(12)
    print(R_)
    R__ = ParallelCircuit(R_, R3)
    print(R__)

----------------------------------------------------

Кроме наследования, существует и другой способ организации 
межклассового взаимодействия – ассоциация (агрегация или композиция),
при которой один класс является полем другого.

Пример композиции:

class Salary:
    def __init__(self, pay):
        self.pay = pay

    def getTotal(self):
        return (self.pay * 12)


class Employee:
    def __init__(self, name, pay, bonus):
        self.name = name
        self.bonus = bonus
        self.salary = Salary(pay)

    def annualSalary(self):
        print(f"{self.name}\'s total: {self.salary.getTotal() + self.bonus}")

if __name__ == '__main__':
    employee = Employee('Ben', 100, 10)
    employee.annualSalary()
----------------------------------------------------------

Пример агрегации:

class Salary:
    def __init__(self, pay):
        self.pay = pay

    def getTotal(self):
        return (self.pay * 12)


class Employee:
    def __init__(self, name, salary, bonus):
        self.name = name
        self.bonus = bonus
        self.salary = salary

    def annualSalary(self):
        print(f"{self.name}\'s total: {self.salary.getTotal() + self.bonus}")

if __name__ == '__main__':
    salary = Salary(100)
    employee = Employee('Ben', salary, 10)
    employee.annualSalary()
------------------------------------------------------------

БАЗА ДАННЫХ ООП-стайл

class Worker:
    def __init__(self, name, salary):
        self.name, self.salary = name, salary
    def __str__(self):
        return f'Worker {self.name}, salary={self.salary}'

class Manager(Worker):
    def __init__(self, name, salary, education):
        Worker.__init__(self, name, salary)
        self.education = education
    def __str__(self):
        return f'Manager {self.name}, salary={self.salary}, educ.={self.education}'

class Department:
    def __init__(self, head, *staff):
        self.head = head
        self.staff = list(staff)
    def show_info(self):
        print(f'Department Head: {self.head.name}, staff={[s.name for s in self.staff]}')
    def show_personal_alphabetical_order(self):
        for p in sorted(self.staff + [self.head], key=lambda x: x.name):
            print(f'|{p.name:^16}|{type(p).__name__:^10}|{float(p.salary):^10.2f}|')


if __name__ == '__main__':
    w1 = Worker('Jones', 2000)
    w2 = Worker('Benson', 1900)
    w3 = Worker('Dembrose', 1700)
    m1 = Manager('Ivanov', 2900, 'ZNTU')
    d1 = Department(m1, w1, w2, w3)
    d1.show_info()
    d1.show_personal_alphabetical_order()
------------------------------------------------------------
Методы класса


class Boy:
    ID = 0
    def __init__(self, name, age):
        self.name, self.age = name, age
        Boy.ID += 1
        self.id = Boy.ID
    def __str__(self):
        return f'Boy {self.name}, age={self.age}, id={self.id}'
    @classmethod
    def from_str(cls, line):
        return cls(line.split()[0], int(line.split()[1]))

    @classmethod
    def from_arr_str(cls, lines):
        return [Boy.from_str(line) for line in lines]

    @classmethod
    def show_ID(cls):
        print(f'next ID will be {cls.ID + 1}')

if __name__ == '__main__':
    boy1 = Boy.from_str('Johnny 12')
    print(boy1)

    s = ['Billy 10', 'Sammy 11']
    boys = Boy.from_arr_str(s)
    for boy in boys:
        print(boy)

    Boy.show_ID()
------------------------------------------------------------------------------
Парсер математических выражений

class MathParser:

    nums = '0123456789.'
    signs = '()*/^+-'

    def __init__(self, lines):
        self.lines = lines
        self.results = []

    def parse(self):
        for line in self.lines:
            print(line)
            line2 = self.clear_line(line)
            print(line2)
            line3 = self.get_line_with_dividers(line2)
            a = self.get_list(line3)
#            print(a)
            b = self.reduce_arr(a)
            print(b)
            self.results.append(b[0])
            print('-' * 30)

    @staticmethod
    def clear_line(string):
        return ''.join([c for c in string if c in MathParser.nums + MathParser.signs])

    @staticmethod
    def get_line_with_dividers(string):
        for n in MathParser.nums:
            for s in MathParser.signs:
                if n + s in string:
                    string = string.replace(n + s, n + '|' + s)
                if s + n in string:
                    string = string.replace(s + n, s + '|' + n)
        for s1 in MathParser.signs:
            for s2 in MathParser.signs:
                if s1 + s2 in string:
                    string = string.replace(s1 + s2, s1 + '|' + s2)
        return string

    @staticmethod
    def get_list(string):
        res = string.split('|')
        for i in range(len(res)):
            if res[i] not in MathParser.signs:
                res[i] = float(res[i])
        return res

    @staticmethod
    def rindex(mylist, myvalue):
        return len(mylist) - mylist[::-1].index(myvalue) - 1

    def reduce_arr(self, arr: list):
        print(arr)
        if '(' in arr:
            i1 = arr.index('(')
            i2 = MathParser.rindex(arr, ')')
            #print(arr[:i1-1], arr[i1+1:i2], arr[i2+1:])
            return self.reduce_arr(arr[:i1] + self.reduce_arr(arr[i1+1:i2]) + arr[i2+1:])
        else:
            while '^' in arr:
                i = arr.index('^')
                res = arr[i-1] ** arr[i + 1]
                print('^', res)
                arr[i-1:i+2] = [res]
                print(arr)
            while self.is_there_unar_minus(arr):
                i = arr.index('-')
                res = -arr[i + 1]
                print('unar-', res)
                #print(i, arr[i:i+2])
                arr[i:i+2] = [res]
                print(arr)
            while '*' in arr:
                i = arr.index('*')
                res = arr[i - 1] * arr[i + 1]
                print('*', res)
                arr[i - 1:i + 2] = [res]
                print(arr)
            while '/' in arr:
                i = arr.index('/')
                res = arr[i - 1] / arr[i + 1]
                print('/', res)
                arr[i - 1:i + 2] = [res]
                print(arr)
            while '+' in arr:
                i = arr.index('+')
                res = arr[i - 1] + arr[i + 1]
                print('+', res)
                arr[i - 1:i + 2] = [res]
                print(arr)
            while '-' in arr:
                i = arr.index('-')
                res = arr[i - 1] - arr[i + 1]
                print('usual-', res)
                arr[i - 1:i + 2] = [res]
                print(arr)

            return arr

    def is_there_unar_minus(self, arr):
        return arr[0]=='-' or \
               any([not(isinstance(arr[i-1], float)) and arr[i]=='-' and \
                    isinstance(arr[i+1], float) for i in range(1, len(arr)-1)])


if __name__ == '__main__':
    lines = ['1+ 2.7',
             '2  *  (3 - 4),',
             '((2+3)*4)^2 - 11.1 / 2',
             '-3 + 4',
             '(11 - 3 * 3) * 7']

    parser = MathParser(lines)
    parser.parse()
    print(parser.results)
---------------------------------------------------------
